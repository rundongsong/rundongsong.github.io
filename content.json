{"pages":[],"posts":[{"title":"JAVA基础知识","text":"JAVA中的名称命名规范：包名:多单词组成时所有字母都小写:xxxyyyzzz类名、接口名:多单词组成时,所有单词的首字母大写:XxxYyyZzz变量名、方法名:多单词组成时,第一个单词首字母小写,第二个单词开始每个单词首字母大写:xxxYyyZzz常量名:所有字母都大写。多单词时每个单词用下划线连接:XXX_YYY_ZZZ JAVA 中变量的分类-按数据的类型基本数据类型：数值型：1.整数类型：int long short byte 2.浮点类型 ：float double 字符型： char 布尔型：boolean 引用数据类型：类 接口 数组 按声明位置不同：成员变量：实例变量和类变量（用static修饰） 局部变量：形参 方法局部变量 代码快局部变量 整数类型变量：​ Java各整数类型有固定的表数范围和字段长度,不受具体OS的影响,以保证java程序的可移植性。​ java的整型常量默认为 int 型,声明long型常量须后加‘l’或‘L’​ java程序中变量通常声明为int型,除非不足以表示较大的数,才使用long 类型 占用存储空间 表数范围 byte 1 byte -128-127 short 2 byte -2^15 - 2^15 -1 int 4 byte -2^31 - 2^31 -1 long 8 byte -2^63 - 2^63 -1 浮点类型变量：与整数类型类似,Java 浮点类型也有固定的表数范围和字段长度,不受具体操作系统的影响。浮点型常量有两种表示形式:十进制数形式:如:5.12 512.0f .512 (必须有小数点)科学计数法形式:如:5.12e2 512E2 100E-2float:单精度,尾数可以精确到7位有效数字。很多情况下,精度很难满足需求。double:双精度,精度是float的两倍。通常采用此类型。Java 的浮点型常量默认为double型,声明float型常量,须后加‘f’或‘F’。 浮点数的表数范围比整数型的要打，但是同等占用空间的精度下降，故浮点数的存储方式应该是小数部分和指数部分分开存储 布尔类型：只有 true 和 false 没有null 也不能用数字代替 编译后在java 虚拟机中都使用虚拟机中的int数据类型代替 基础数据类型转换：自动类型转换:容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为: char byte —–&gt; int ——–&gt; long —–&gt; float ——-&gt;float ——–&gt; double short 有多种类型的数据混合运算时,系统首先自动将所有数据转换成容量最大的那种数据类型,然后再进行计算。byte,short,char之间不会相互转换,他们三者在计算时首先转换为int类型。boolean类型不能与其它数据类型运算。当把任何基本数据类型的值和字符串(String)进行连接运算时(+),基本数据类型的值将自动转化为字符串(String)类型。 String 类型测试：（稍后进行）基本原则是从左向右，有String 转成String 强制类型转换：自动类型转换的逆过程,将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符:(),但可能造成精度降低或溢出,格外要注意。 字符串不能直接转换，但是可以通过基本类型的包装类完成： 123String a=&quot;43&quot;int i = Integer.parseInt(a) 如果赋值的类型不同是否可以实现？如将short赋值给int 或者是反向操作，稍后尝试一下。 后续尝试 11-20 123456789101112131415161718192021222324252627282930public class StringTest { public static void main(String[] args) { long a = 50000; long b = 10000l;//加不加l没有看到明显的区别 System.out.println(getType(a)); System.out.println(getType(b)); int c = 10 ; System.out.println(getType(b+c));// int + long 转化成了long char s='A'; System.out.println(getType(s+c));// 类型为integer String ss=&quot;A&quot;; System.out.println(s+c);// 结果为75 System.out.println(ss+c);// 结果为A10 short aa= 10; int ax=aa; System.out.println(ax+getType(ax));// 结果为integer int bb=10;// short bx=bb ; 有报错提示 } public static String getType(Object o){ return o.getClass().toString(); }}","link":"/2020/11/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"","text":"PIV 处理实验数据（一）Particle Image Velocimetry,又称粒子图像测速法，是七十年代末发展起来的一种瞬态、多点、无接触式的流体力学测速方法。近几十年来得到了不断完善与发展，PIV技术的特点是超出了单点测速技术(如LDA)的局限性，能在同一瞬态记录下大量空间点上的速度分布信息，并可提供丰富的流场空间结构以及流动特性。 目前进程： 在octave上编写程序，基本框架如下： 将图片导入程序用img1，img2，保存成为两个矩阵 在第一张图片上选取32像素*32像素大小的块与第二章图片相同大小的块进行互相关性分析 互相关性分析所需要的计算量过大，采用快速傅里叶变化（FFT）算法加速计算效率。第二张图块每次移动16个像素单位，如果该数值设置过大，则精度降低，若设置过小运行速度过慢。由于给定的素材图片是2048*2048，所需要的计算量非常巨大，计算时间也非常长，这里想到可以将相关性的计算简化成为灰度值相减的绝对值，比起FFT的计算过程更加简便，效果尚未验证。 使用quiver和contourf进行可视化处理 尚未进行的工作有程序还在云端运行，结果仍未知。 进行过程中遇到的问题未遇到值得记录的问题 Version 1代码附录在下 12345function [img1 img2] = LoadPicture () img1=imread(&quot;i1.tif&quot;); img2=imread(&quot;i2.tif&quot;); endfunction 12345678910function Rnumber = FFTCrossCorrelation (x1 , y1 , x2 , y2, img1 , img2 )%框选数据范围f = img1(x1-15:x1+16, y1-15: y1+16 );g = img2(x2-15:x2+16, y2-15: y2+16 );F = fft (f);G = fft (g);X = conj (F)* G;R = ifft (X);Rnumber = sum(sum(abs(R)));endfunction 12345function [u v] = VelocityVector (x1 , y1 , x2 , y2) t=10; u = (x2-x1)/t; v = (y2 - y1)/t;endfunction 123456789101112131415161718192021222324function [u v] = main ()[img1 img2]=LoadPicture();u = zeros(2048,2048);v = zeros(2048,2048);R = zeros(2048,2048);for x1 = 16:16:2032, x1/2032 for y1 = 16:16:2032, for i = 16:16:2032, for j = 16:16:2032, R(i,j)=FFTCrossCorrelation(x1,y1,i,j,img1,img2); end; end; [x ix]=max(R); [y iy]=max(x); ix1 = ix (1,iy); [uvalue vvalue]=VelocityVector(x1,y1,ix1,iy); u(x1,y1)=uvalue; v(x1,y1)=vvalue; end; end; endfunction","link":"/2020/11/20/PIV%20%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/09/hello-world/"},{"title":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function [u v] = main (img11,img22)##Flip Pictureimg1=flip(img11);img2=flip(img22);##divide picuture into many tiny parts[numx numy h1 w1 h2 w2 px limit] = setData (img1,img2);##create v-matrix and u-matrixv = zeros(numy,numx);u = zeros(numy,numx);##set delta when searching in search windowdelta =1;##set Rlimit to filter the too little RRlimit=0.4;##scan point in every partfor xx =1:numx,##show rate of progress xx/numx for yy = 1:numy,##get central coordinate [x y]=location(xx,yy,px);##range size is obtained from the center coordinates [x1 x2 y1 y2] = range_location (x,y,px);##obtain the range f=img1(y1:y2,x1:x2);##search window's range size is obtained from the center coordinates [x11 x22 y11 y22] = locaton_search (x,y,limit);##get the change range in the search window [x0 y0 nx ny n1x n1y] = zeroset (x,y,x11,x22,y11,y22,px,limit,delta);##create R-matrix R=zeros(ny+1,nx+1);##scan point by point for i = 1:nx+1, for j= 1:ny+1,##get central coordinate xs=x0+(i-1)*delta; ys=y0+(j-1)*delta;##range size is obtained from the center coordinates [sx1 sx2 sy1 sy2]=range_location (xs,ys,px);##obtain the range g=img2(sy1:sy2,sx1:sx2);##calculate the correlation between the two matrices R(j,i)=corr2(f,g); end; end; ##the abscissa and ordinate of the maximum correlation are obtained [c iy]=max(R); [Rvalue ix]=max(c); iy1 = iy (1,ix);##screening to remove the situation of low correlation if Rvalue&gt;Rlimit,##calculate u and v [uvalue vvalue]=VelocityVector(n1x+1,n1y+1,ix,iy1); u(yy,xx)=uvalue.*delta; v(yy,xx)=vvalue.*delta; else, u(yy,xx)=0.; v(yy,xx)=0.; end; end;end;##save the datasave zhongjiu.txt u;save zhongjiv.txt v;endfunction 123456789101112function [numx numy h1 w1 h2 w2 px limit] = setData (img1,img2)##得到图像的宽和高[h1 w1]=size(img1);[h2 w2]=size(img2);##设置分解小块的大小px=32;##将图像进行划分numx=floor(w1/px);numy=floor(h1/px);##设置搜索框的大小limit=64endfunction 12345function [x y] = location (numx, numy,px)##由小块的序号值推及中心坐标值x = (1+px)/2+(numx-1)*px;y = (1+px)/2+(numy-1)*px;endfunction 1234567function [x1 x2 y1 y2] = range_location (x,y,px)##由中心坐标以及小块的大小确定四个边的位置x1=ceil(x)-px/2;x2 = x1 +px -1;y1=ceil(y)-px/2;y2 = y1 +px -1;endfunction 1234567891011121314151617181920function [x1 x2 y1 y2] = locaton_search (x,y,limit)##由中心坐标以及搜索框的大小确定四个边的位置x1=ceil(x)-limit/2;x2 = x1 +limit -1;y1=ceil(y)-limit/2;y2 = y1 +limit -1;##防止超出图像范围if x1&lt;1, x1=1;end;if y1&lt;1, y1=1;end;if x2&gt;2048, x2=2048;end;if y2&gt;2048, y2=2048;end;endfunction 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function [x1 y1 nx ny n1x n1y] = zeroset (x,y,x11,x22,y11,y22,px,limit,delta)##在搜索窗范围内得到最左上角的坐标值，以及记录回退次数n1x=0;n2x =0;n1y =0;n2y =0;flag=0;x1 =x;while x1-ceil(px/2)&gt;=x11, n1x=n1x+1; x1=x-n1x*delta; flag=1;end;if flag==1, n1x=n1x-1; else, n1x=n1x;end;flag=0;x1 =x;while x1+ceil(px/2)&lt;=x22, n2x=n2x+1; x1=x+n2x*delta; flag=1;end;if flag==1, n2x=n2x-1; else, n2x=n2x;end;%n2x=n2x-1;x1 =x-n1x*delta;nx = n1x +n2x;flag=0;y1 =y;while y1-ceil(px/2)&gt;=y11, n1y=n1y+1; y1=y-n1y*delta; flag=1;end;%n1y=n1y-1;if flag==1, n1y=n1y-1; else, n1y=n1y;end;y1 =y;while y1+ceil(px/2)&lt;=y22, n2y=n2y+1; y1=y+n2y*delta; flag=1;end;%n2y=n2y-1;if flag==1, n2y=n2y-1; else, n2y=n2y;end;y1 =y-n1y*delta;ny = n1y +n2y;endfunction 123456789101112function r = corr2 (a,b)##计算二维矩阵的相关性c=sqrt(sum(sum(a.*a))*sum(sum(b.*b)));a = a - mean2(a); b = b - mean2(b);##处理当有一组全为0时的特殊情况 if c~=0, r = sum(sum(a.*b))/c; else, r=0;end;endfunction 123456function [u v] = VelocityVector (x1 , y1 , x2 , y2)##计算得出u v的数值 t=1; u = (x2-x1)./t; v = (y2-y1)./t;endfunction 12345678910function [u v] = preprocessing()##导入图像I1 = imread('i1.tif');I2 = imread('i2.tif');##基于otsu算法计算levellevel = graythresh(I1);##对图像进行二元化处理，增强对比度BW1 = im2bw(I1,level);BW2 = im2bw(I2,level);endfunction","link":"/2020/11/25/piv%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/"},{"title":"my first blog","text":"ITTTTTTTTTTT","link":"/2020/11/09/my-first-blog/"},{"title":"","text":"《算法图解》阅读笔记（一）（p1-p86）二分查找：二分查找法是一种效率极高的查找方法，有着O(log n)的时间复杂度，当n的数据巨大时，二分查找比简单查找的效果高的多，但是二分查找的序列必须是一个有序序列。这点要求比起简单查找苛刻不少二分查找的代码实现： 123456789101112def binary_search(list,item): low=0 high=len(list)-1 while low&lt;=high: mid = int ((ow+high)/2) if list[mid]==item: return mid if list[mid]&lt;item: min=mid+1 else: max=mid-1 return None 数组是在内存中占一段连续的空间，在读取数据时非常方便但是在写入删除数据时比较麻烦 链表在内存中不连续，只要内存够大就可以创建，在读取数据时并不方便，但是在写入删除数据方面有优势(python 怎么实现链表？) 选择排序：数组循环n次每次选出最小的数值 123456789101112131415def findsmallest(arr): smallest=arr[o] small_index =0 for i in range (len(arr)): if arr[i]&lt;smallest: smallest=arr[i] small_index=i return small_indexdef selectSort(arr): newArr=[] for i in range (len(arr)): smallest=findsmallest(arr) newArr.append(arr.pop(smallest)) return newArr 栈：栈的基本功能，压入和弹出 调用栈：计算机内部使用的被称为调用栈的栈。内存当中函数的调用过程就是基于栈的功能来实现的。","link":"/2020/11/20/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88p1-p86%EF%BC%89/"},{"title":"","text":"piv计算粒子加速度后续​ 之前的算法运行时间过长，计算得到的点数太多用octave在画图时总是崩溃，无法验证结果如何。故重新设计了算法，经过几天的迭代更新得到了有效的PIV程序，运行结果完美，速度也快了很多，代码保存在https://github.com/rundongsong/piv。 下面回顾一下实现的思想： ​ 1.首先注意到图像中的黑色部分灰度值并不相同，所以用otsu算法对图像进行二元化处理，得到对比度更强烈的图像。 ​ 2.对一个32像素 32像素的块，在其周围64像素 64像素的范围内进行搜索，选择相关性最大的块计算速度 ​ 3.对结果进行筛选，处理。在仓库中还有一些用于数据处理的函数，最新一个的操作处理中并没有使用到故不再赘述。 ​ 整个实现过程中出的最大的一个问题是将octave中的corr函数等同于matlab中的corr2使用，出现很多问题点。 ​ octave中的corr 如果变量设置为两个矩阵，所计算的是每一个列向量的相关性，并不等同于是二维矩阵的相关性计算。故需要重新写一个corr2函数。","link":"/2020/11/25/piv%E8%AE%A1%E7%AE%97%E7%B2%92%E5%AD%90%E5%8A%A0%E9%80%9F%E5%BA%A6%E5%90%8E%E7%BB%AD/"}],"tags":[],"categories":[]}