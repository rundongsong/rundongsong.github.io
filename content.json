{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/11/09/hello-world/"},{"title":"","text":"PIV 处理实验数据（一）Particle Image Velocimetry,又称粒子图像测速法，是七十年代末发展起来的一种瞬态、多点、无接触式的流体力学测速方法。近几十年来得到了不断完善与发展，PIV技术的特点是超出了单点测速技术(如LDA)的局限性，能在同一瞬态记录下大量空间点上的速度分布信息，并可提供丰富的流场空间结构以及流动特性。 目前进程： 在octave上编写程序，基本框架如下： 将图片导入程序用img1，img2，保存成为两个矩阵 在第一张图片上选取32像素*32像素大小的块与第二章图片相同大小的块进行互相关性分析 互相关性分析所需要的计算量过大，采用快速傅里叶变化（FFT）算法加速计算效率。第二张图块每次移动16个像素单位，如果该数值设置过大，则精度降低，若设置过小运行速度过慢。由于给定的素材图片是2048*2048，所需要的计算量非常巨大，计算时间也非常长，这里想到可以将相关性的计算简化成为灰度值相减的绝对值，比起FFT的计算过程更加简便，效果尚未验证。 使用quiver和contourf进行可视化处理 尚未进行的工作有程序还在云端运行，结果仍未知。 进行过程中遇到的问题未遇到值得记录的问题 Version 1代码附录在下 12345function [img1 img2] = LoadPicture () img1=imread(&quot;i1.tif&quot;); img2=imread(&quot;i2.tif&quot;); endfunction 12345678910function Rnumber = FFTCrossCorrelation (x1 , y1 , x2 , y2, img1 , img2 )%框选数据范围f = img1(x1-15:x1+16, y1-15: y1+16 );g = img2(x2-15:x2+16, y2-15: y2+16 );F = fft (f);G = fft (g);X = conj (F)* G;R = ifft (X);Rnumber = sum(sum(abs(R)));endfunction 12345function [u v] = VelocityVector (x1 , y1 , x2 , y2) t=10; u = (x2-x1)/t; v = (y2 - y1)/t;endfunction 123456789101112131415161718192021222324function [u v] = main ()[img1 img2]=LoadPicture();u = zeros(2048,2048);v = zeros(2048,2048);R = zeros(2048,2048);for x1 = 16:16:2032, x1/2032 for y1 = 16:16:2032, for i = 16:16:2032, for j = 16:16:2032, R(i,j)=FFTCrossCorrelation(x1,y1,i,j,img1,img2); end; end; [x ix]=max(R); [y iy]=max(x); ix1 = ix (1,iy); [uvalue vvalue]=VelocityVector(x1,y1,ix1,iy); u(x1,y1)=uvalue; v(x1,y1)=vvalue; end; end; endfunction","link":"/2020/11/20/PIV%20%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"","text":"《算法图解》阅读笔记（一）（p1-p86）二分查找：二分查找法是一种效率极高的查找方法，有着O(log n)的时间复杂度，当n的数据巨大时，二分查找比简单查找的效果高的多，但是二分查找的序列必须是一个有序序列。这点要求比起简单查找苛刻不少二分查找的代码实现： 123456789101112def binary_search(list,item): low=0 high=len(list)-1 while low&lt;=high: mid = int ((ow+high)/2) if list[mid]==item: return mid if list[mid]&lt;item: min=mid+1 else: max=mid-1 return None 数组是在内存中占一段连续的空间，在读取数据时非常方便但是在写入删除数据时比较麻烦 链表在内存中不连续，只要内存够大就可以创建，在读取数据时并不方便，但是在写入删除数据方面有优势(python 怎么实现链表？) 选择排序：数组循环n次每次选出最小的数值 123456789101112131415def findsmallest(arr): smallest=arr[o] small_index =0 for i in range (len(arr)): if arr[i]&lt;smallest: smallest=arr[i] small_index=i return small_indexdef selectSort(arr): newArr=[] for i in range (len(arr)): smallest=findsmallest(arr) newArr.append(arr.pop(smallest)) return newArr 栈：栈的基本功能，压入和弹出 调用栈：计算机内部使用的被称为调用栈的栈。内存当中函数的调用过程就是基于栈的功能来实现的。","link":"/2020/11/20/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88p1-p86%EF%BC%89/"},{"title":"my first blog","text":"ITTTTTTTTTTT","link":"/2020/11/09/my-first-blog/"},{"title":"JAVA基础知识","text":"JAVA中的名称命名规范：包名:多单词组成时所有字母都小写:xxxyyyzzz类名、接口名:多单词组成时,所有单词的首字母大写:XxxYyyZzz变量名、方法名:多单词组成时,第一个单词首字母小写,第二个单词开始每个单词首字母大写:xxxYyyZzz常量名:所有字母都大写。多单词时每个单词用下划线连接:XXX_YYY_ZZZ JAVA 中变量的分类-按数据的类型基本数据类型：数值型：1.整数类型：int long short byte 2.浮点类型 ：float double 字符型： char 布尔型：boolean 引用数据类型：类 接口 数组 按声明位置不同：成员变量：实例变量和类变量（用static修饰） 局部变量：形参 方法局部变量 代码快局部变量 整数类型变量：​ Java各整数类型有固定的表数范围和字段长度,不受具体OS的影响,以保证java程序的可移植性。​ java的整型常量默认为 int 型,声明long型常量须后加‘l’或‘L’​ java程序中变量通常声明为int型,除非不足以表示较大的数,才使用long 类型 占用存储空间 表数范围 byte 1 byte -128-127 short 2 byte -2^15 - 2^15 -1 int 4 byte -2^31 - 2^31 -1 long 8 byte -2^63 - 2^63 -1 浮点类型变量：与整数类型类似,Java 浮点类型也有固定的表数范围和字段长度,不受具体操作系统的影响。浮点型常量有两种表示形式:十进制数形式:如:5.12 512.0f .512 (必须有小数点)科学计数法形式:如:5.12e2 512E2 100E-2float:单精度,尾数可以精确到7位有效数字。很多情况下,精度很难满足需求。double:双精度,精度是float的两倍。通常采用此类型。Java 的浮点型常量默认为double型,声明float型常量,须后加‘f’或‘F’。 浮点数的表数范围比整数型的要打，但是同等占用空间的精度下降，故浮点数的存储方式应该是小数部分和指数部分分开存储 布尔类型：只有 true 和 false 没有null 也不能用数字代替 编译后在java 虚拟机中都使用虚拟机中的int数据类型代替 基础数据类型转换：自动类型转换:容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为: char byte —–&gt; int ——–&gt; long —–&gt; float ——-&gt;float ——–&gt; double short 有多种类型的数据混合运算时,系统首先自动将所有数据转换成容量最大的那种数据类型,然后再进行计算。byte,short,char之间不会相互转换,他们三者在计算时首先转换为int类型。boolean类型不能与其它数据类型运算。当把任何基本数据类型的值和字符串(String)进行连接运算时(+),基本数据类型的值将自动转化为字符串(String)类型。 String 类型测试：（稍后进行）基本原则是从左向右，有String 转成String 强制类型转换：自动类型转换的逆过程,将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符:(),但可能造成精度降低或溢出,格外要注意。 字符串不能直接转换，但是可以通过基本类型的包装类完成： 123String a=&quot;43&quot;int i = Integer.parseInt(a) 如果赋值的类型不同是否可以实现？如将short赋值给int 或者是反向操作，稍后尝试一下。 后续尝试 11-20 123456789101112131415161718192021222324252627282930public class StringTest { public static void main(String[] args) { long a = 50000; long b = 10000l;//加不加l没有看到明显的区别 System.out.println(getType(a)); System.out.println(getType(b)); int c = 10 ; System.out.println(getType(b+c));// int + long 转化成了long char s='A'; System.out.println(getType(s+c));// 类型为integer String ss=&quot;A&quot;; System.out.println(s+c);// 结果为75 System.out.println(ss+c);// 结果为A10 short aa= 10; int ax=aa; System.out.println(ax+getType(ax));// 结果为integer int bb=10;// short bx=bb ; 有报错提示 } public static String getType(Object o){ return o.getClass().toString(); }}","link":"/2020/11/18/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"}],"tags":[],"categories":[]}